package service

import (
	"context"
	"fmt"

	"github.com/cornelk/hashmap"
	"github.com/ethereum/go-ethereum/common"
	"github.com/synapsecns/sanguine/core/metrics"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

const meterName = "github.com/synapsecns/sanguine/services/rfq/guard/service"

// generate an interface for otelRecorder that exports the public method.
// this allows us to avoid using recordX externally anad makes the package less confusing.
//
// =============================================================================
// =============================================================================
// IMPORTANT: DO NOT REMOVE THIS COMMENT.
// NOTICE: PLEASE MAKE SURE YOU UPDATE BOTH THE DOCS AND THE GRAFANA DASHBOARD (IF NEEDED) AFTER UPDATING METRICS.
// =============================================================================
// =============================================================================
//
//go:generate go run github.com/vburenin/ifacemaker -f otel.go -s otelRecorder -i iOtelRecorder -p service -o otel_generated.go -c "autogenerated file"
type otelRecorder struct {
	metrics metrics.Handler
	// meter is the metrics meter.
	meter metric.Meter
	// disputeGauge is the gauge for the disputeCounts.
	disputeGauge metric.Int64ObservableGauge
	// disputeCounts is used for metrics.
	// chainID -> count
	disputeCounts *hashmap.Map[int, int]
	// walletAddress is the wallet address for the signer.
	walletAddress common.Address
}

func newOtelRecorder(meterHandler metrics.Handler, walletAddress common.Address) (_ iOtelRecorder, err error) {
	or := otelRecorder{
		metrics:       meterHandler,
		meter:         meterHandler.Meter(meterName),
		disputeCounts: hashmap.New[int, int](),
		walletAddress: walletAddress,
	}

	or.disputeGauge, err = or.meter.Int64ObservableGauge("dispute_count")
	if err != nil {
		return nil, fmt.Errorf("could not create dispute count gauge: %w", err)
	}

	_, err = or.meter.RegisterCallback(or.recordDisputeCounts, or.disputeGauge)
	if err != nil {
		return nil, fmt.Errorf("could not register callback for dispute count gauge: %w", err)
	}

	return &or, nil
}

func (o *otelRecorder) recordDisputeCounts(_ context.Context, observer metric.Observer) (err error) {
	if o.metrics == nil || o.disputeGauge == nil || o.disputeCounts == nil {
		return nil
	}

	o.disputeCounts.Range(func(chainID int, count int) bool {
		opts := metric.WithAttributes(
			attribute.Int("chain_id", int(chainID)),
			attribute.String("wallet", o.signer.Address().Hex()),
		)
		observer.ObserveInt64(o.disputeGauge, int64(count), opts)

		return true
	})

	return nil
}

// RecordDisputeCount records the request dispute count.
func (o *otelRecorder) RecordDispute(chainID int) {
	count, ok := o.disputeCounts.Get(chainID)
	if ok {
		o.disputeCounts.Set(chainID, count+1)
	} else {
		o.disputeCounts.Set(chainID, 1)
	}
}
